diff --git a/src/java/org/apache/cassandra/cql3/QueryProcessor.java b/src/java/org/apache/cassandra/cql3/QueryProcessor.java
index 0c607352da..646db994f2 100644
--- a/src/java/org/apache/cassandra/cql3/QueryProcessor.java
+++ b/src/java/org/apache/cassandra/cql3/QueryProcessor.java
@@ -252,6 +252,8 @@ public class QueryProcessor implements QueryHandler
 
         if (!queryState.getClientState().isInternal)
             metrics.regularStatementsExecuted.inc();
+        
+        System.out.println("    ---- @meng: public ResultMessage process: " + queryString);
 
         return processStatement(prepared, queryState, options, queryStartNanoTime);
     }
diff --git a/src/java/org/apache/cassandra/io/util/BufferedDataOutputStreamPlus.java b/src/java/org/apache/cassandra/io/util/BufferedDataOutputStreamPlus.java
index 54122ee3e7..d9c70cc08a 100644
--- a/src/java/org/apache/cassandra/io/util/BufferedDataOutputStreamPlus.java
+++ b/src/java/org/apache/cassandra/io/util/BufferedDataOutputStreamPlus.java
@@ -23,6 +23,8 @@ import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.channels.WritableByteChannel;
+import sun.nio.ch.SocketChannelImpl;
+
 
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
@@ -310,7 +312,8 @@ public class BufferedDataOutputStreamPlus extends DataOutputStreamPlus
         for (ByteBuffer buffer : memory.asByteBuffers(offset, length))
             write(buffer);
     }
-
+    
+    
     /*
      * Count is the number of bytes remaining to write ignoring already remaining capacity
      */
@@ -324,6 +327,29 @@ public class BufferedDataOutputStreamPlus extends DataOutputStreamPlus
 
         buffer.clear();
     }
+    
+    
+    /*
+     * Count is the number of bytes remaining to write ignoring already remaining capacity
+     */
+    @DontInline
+    public void doFlushMittcpu(int id) throws IOException
+    {
+        buffer.flip();
+        
+        while (buffer.hasRemaining()) {
+            if(channel instanceof SocketChannelImpl) {
+                System.out.println("    @meng: doFlushMittcpu id: " + Integer.toString(id));
+                ((SocketChannelImpl)channel).writeMittcpu(buffer, id);
+            }
+            else {
+                channel.write(buffer);
+            }
+        }
+
+        buffer.clear();
+    }
+    
 
     @Override
     public void flush() throws IOException
diff --git a/src/java/org/apache/cassandra/net/IncomingTcpConnection.java b/src/java/org/apache/cassandra/net/IncomingTcpConnection.java
index c96dc6e1dc..b34f593ee4 100644
--- a/src/java/org/apache/cassandra/net/IncomingTcpConnection.java
+++ b/src/java/org/apache/cassandra/net/IncomingTcpConnection.java
@@ -138,6 +138,7 @@ public class IncomingTcpConnection extends FastThreadLocalThread implements Clos
     private void receiveMessages() throws IOException
     {
         // handshake (true) endpoint versions
+    	
         DataOutputStream out = new DataOutputStream(socket.getOutputStream());
         // if this version is < the MS version the other node is trying
         // to connect with, the other node will disconnect
@@ -185,7 +186,7 @@ public class IncomingTcpConnection extends FastThreadLocalThread implements Clos
     }
 
     private InetAddress receiveMessage(DataInputPlus input, int version) throws IOException
-    {
+    {	
         int id;
         if (version < MessagingService.VERSION_20)
             id = Integer.parseInt(input.readUTF());
diff --git a/src/java/org/apache/cassandra/net/MessageOut.java b/src/java/org/apache/cassandra/net/MessageOut.java
index 4f41ee5a1a..64d102c23d 100644
--- a/src/java/org/apache/cassandra/net/MessageOut.java
+++ b/src/java/org/apache/cassandra/net/MessageOut.java
@@ -45,6 +45,17 @@ public class MessageOut<T>
     private long payloadSize = -1;
     private int payloadSizeVersion = -1;
 
+    private int deadline = 0;
+
+    public int getDeadline() {
+        return deadline;
+    }
+
+    public void setDeadline(int deadline) 
+    {
+        this.deadline = deadline;
+    }
+
     // we do support messages that just consist of a verb
     public MessageOut(MessagingService.Verb verb)
     {
@@ -80,7 +91,9 @@ public class MessageOut<T>
     {
         ImmutableMap.Builder<String, byte[]> builder = ImmutableMap.builder();
         builder.putAll(parameters).put(key, value);
-        return new MessageOut<T>(verb, payload, serializer, builder.build());
+        MessageOut<T> newMessage = new MessageOut<T>(verb, payload, serializer, builder.build());
+        newMessage.setDeadline(this.deadline);
+        return newMessage;
     }
 
     public Stage getStage()
diff --git a/src/java/org/apache/cassandra/net/MessagingService.java b/src/java/org/apache/cassandra/net/MessagingService.java
index dfca087f58..fb8947747a 100644
--- a/src/java/org/apache/cassandra/net/MessagingService.java
+++ b/src/java/org/apache/cassandra/net/MessagingService.java
@@ -877,6 +877,11 @@ public final class MessagingService implements MessagingServiceMBean
         return sendRR(message, to, cb, message.getTimeout(), true);
     }
 
+    public int sendRRWithFailureMittcpu(MessageOut message, InetAddress to, IAsyncCallbackWithFailure cb)
+    {
+        return sendRRMittcpu(message, to, cb, message.getTimeout(), true);
+    }
+    
     /**
      * Send a non-mutation message to a given endpoint. This method specifies a callback
      * which is invoked with the actual response.
@@ -896,6 +901,16 @@ public final class MessagingService implements MessagingServiceMBean
         return id;
     }
 
+    
+    public int sendRRMittcpu(MessageOut message, InetAddress to, IAsyncCallback cb, long timeout, boolean failureCallback)
+    {
+        int id = addCallback(cb, message, to, timeout, failureCallback);
+        updateBackPressureOnSend(to, cb, message);
+        sendOneWayMittcpu(failureCallback ? message.withParameter(FAILURE_CALLBACK_PARAM, ONE_BYTE) : message, id, to);
+        return id;
+    }
+    
+    
     /**
      * Send a mutation message or a Paxos Commit to a given endpoint. This method specifies a callback
      * which is invoked with the actual response.
@@ -955,6 +970,29 @@ public final class MessagingService implements MessagingServiceMBean
         // write it
         connection.enqueue(message, id);
     }
+    
+    
+    public void sendOneWayMittcpu(MessageOut message, int id, InetAddress to)
+    {
+        if (logger.isTraceEnabled())
+            logger.trace("{} sending {} to {}@{}", FBUtilities.getBroadcastAddress(), message.verb, id, to);
+
+        if (to.equals(FBUtilities.getBroadcastAddress()))
+            logger.trace("Message-to-self {} going over MessagingService", message);
+
+        // message sinks are a testing hook
+        for (IMessageSink ms : messageSinks)
+            if (!ms.allowOutgoingMessage(message, id, to))
+                return;
+
+        // get pooled connection (really, connection queue)
+        OutboundTcpConnection connection = getConnection(to, message);
+        
+        connection.startRecvThread();;
+
+        // write it
+        connection.enqueue(message, id);
+    }
 
     public <T> AsyncOneResponse<T> sendRR(MessageOut message, InetAddress to)
     {
@@ -1303,7 +1341,7 @@ public final class MessagingService implements MessagingServiceMBean
                         socket.close();
                         continue;
                     }
-
+                    
                     socket.setKeepAlive(true);
                     socket.setSoTimeout(2 * OutboundTcpConnection.WAIT_FOR_VERSION_MAX_TIME);
                     // determine the connection type to decide whether to buffer
diff --git a/src/java/org/apache/cassandra/net/OutboundTcpConnection.java b/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
index 4ae62c1d0b..80d8d5dd36 100644
--- a/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
+++ b/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
@@ -86,7 +86,9 @@ public class OutboundTcpConnection extends FastThreadLocalThread
     private static final int BUFFER_SIZE = Integer.getInteger(BUFFER_SIZE_PROPERTY, 1024 * 64);
 
     public static final int MAX_COALESCED_MESSAGES = 128;
-
+    
+    
+    
     private static CoalescingStrategy newCoalescingStrategy(String displayName)
     {
         return CoalescingStrategies.newCoalescingStrategy(DatabaseDescriptor.getOtcCoalescingStrategy(),
@@ -151,6 +153,23 @@ public class OutboundTcpConnection extends FastThreadLocalThread
     private volatile int currentMsgBufferCount = 0;
     private volatile int targetVersion;
 
+    
+    private  boolean recvThreadCreated = false;
+    private  Thread recvTcpThread;
+    
+    public void startRecvThread() {
+        if (recvThreadCreated)
+            return;
+        RecvTcpLoop recvTcpLoop = new RecvTcpLoop(this);
+        recvTcpThread = new Thread(recvTcpLoop);
+        recvTcpThread.start();
+        recvThreadCreated = true;
+    }
+    
+    public Socket getSocket() {
+    	return socket;
+    }
+    
     public OutboundTcpConnection(OutboundTcpConnectionPool pool, String name)
     {
         super("MessagingService-Outgoing-" + pool.endPoint() + "-" + name);
@@ -227,6 +246,8 @@ public class OutboundTcpConnection extends FastThreadLocalThread
         // keeping list (batch) size small for now; that way we don't have an unbounded array (that we never resize)
         final List<QueuedMessage> drainedMessages = new ArrayList<>(drainedMessageSize);
 
+        
+        
         outer:
         while (!isStopped)
         {
@@ -259,8 +280,9 @@ public class OutboundTcpConnection extends FastThreadLocalThread
 
                     if (qm.isTimedOut(System.nanoTime()))
                         dropped.incrementAndGet();
-                    else if (socket != null || connect())
+                    else if (socket != null || connect()) {
                         writeConnected(qm, count == 1 && backlog.isEmpty());
+                    }
                     else
                     {
                         // Not connected! Clear out the queue, else gossip messages back up. Update dropped
@@ -313,6 +335,9 @@ public class OutboundTcpConnection extends FastThreadLocalThread
     {
         try
         {
+            if (socket.getInetAddress().getHostAddress().equals("155.98.36.78")) {
+                System.out.println("    @meng: sending something to 155.98.36.78...");
+            }
             byte[] sessionBytes = qm.message.parameters.get(Tracing.TRACE_HEADER);
             if (sessionBytes != null)
             {
@@ -338,8 +363,12 @@ public class OutboundTcpConnection extends FastThreadLocalThread
             writeInternal(qm.message, qm.id, timestampMillis);
 
             completed++;
-            if (flush)
-                out.flush();
+            if (flush) {
+                if ((qm.message.getDeadline() == 1) && (out instanceof BufferedDataOutputStreamPlus))
+                    ((BufferedDataOutputStreamPlus)out).doFlushMittcpu(qm.id);
+                else
+                    out.flush();
+            }
         }
         catch (Throwable e)
         {
@@ -460,7 +489,7 @@ public class OutboundTcpConnection extends FastThreadLocalThread
                 out.writeInt(MessagingService.PROTOCOL_MAGIC);
                 writeHeader(out, targetVersion, shouldCompressConnection());
                 out.flush();
-
+                
                 DataInputStream in = new DataInputStream(socket.getInputStream());
                 int maxTargetVersion = handshakeVersion(in);
                 if (maxTargetVersion == NO_VERSION)
diff --git a/src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java b/src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java
index 9f9ffeef1d..6234ab9ed1 100644
--- a/src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java
+++ b/src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java
@@ -65,6 +65,10 @@ public class OutboundTcpConnectionPool
 
         this.backPressureState = backPressureState;
     }
+    
+    public InetAddress getID() {
+    	return id;
+    }
 
     /**
      * returns the appropriate connection based on message type.
diff --git a/src/java/org/apache/cassandra/net/RecvRunnable.java b/src/java/org/apache/cassandra/net/RecvRunnable.java
new file mode 100644
index 0000000000..e3e1f107b8
--- /dev/null
+++ b/src/java/org/apache/cassandra/net/RecvRunnable.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.net;
+
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.nio.ByteBuffer;
+
+import org.apache.cassandra.db.ReadCommand;
+import org.apache.cassandra.service.ReadCallback;
+import org.apache.cassandra.tracing.Tracing;
+
+
+public class RecvRunnable implements Runnable {
+	public MessageOut<ReadCommand> message;
+	public InetAddress endpoint;
+	public int id;
+	
+	public RecvRunnable(MessageOut<ReadCommand> message, InetAddress endpoint, int id) {
+		this.message = message;
+		this.endpoint = endpoint;
+		this.id = id;
+	}
+	
+	public void run() {
+		OutboundTcpConnection connection = MessagingService.instance().getConnectionPool(endpoint).getConnection(message);
+		Socket socket = connection.getSocket();
+		if (socket != null) {
+	        try {
+	        	InputStream in = socket.getInputStream();
+	        	int n = in.read();
+	        	
+	        	if (n == -16) {
+	        	    System.out.println("  @meng: Request is Mittcpu Reject from " + socket.getRemoteSocketAddress().toString());
+	        	    
+	                CallbackInfo callbackInfo = MessagingService.instance().removeRegisteredCallback(id);
+	                if (callbackInfo == null)
+	                    return;
+	                
+	                IAsyncCallback cb = callbackInfo.callback;
+	                if (cb instanceof ReadCallback) {
+	                    ((ReadCallback) cb).onMittcpuRejection();
+	                }
+	        	}
+	        } catch (Exception e) {
+	        	System.out.println(e.getStackTrace());
+	        }
+	        
+		}
+		
+	}
+	
+	
+}
+
+
diff --git a/src/java/org/apache/cassandra/net/RecvTcpLoop.java b/src/java/org/apache/cassandra/net/RecvTcpLoop.java
new file mode 100644
index 0000000000..5428c2b7ac
--- /dev/null
+++ b/src/java/org/apache/cassandra/net/RecvTcpLoop.java
@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.net;
+
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.nio.ByteBuffer;
+
+import org.apache.cassandra.db.ReadCommand;
+import org.apache.cassandra.service.ReadCallback;
+import org.apache.cassandra.tracing.Tracing;
+
+import sun.nio.ch.ChannelInputStream;
+
+
+public class RecvTcpLoop implements Runnable {
+    public OutboundTcpConnection outboundTcpConnection;
+    
+    public RecvTcpLoop(OutboundTcpConnection outboundTcpConnection) {
+        this.outboundTcpConnection = outboundTcpConnection;
+    }
+    
+    public void run() {
+        System.out.println("   @meng: RecvTcpLoop has been created. endpoint: " + 
+                    outboundTcpConnection.getSocket().getInetAddress().getHostAddress());
+
+        Socket socket = outboundTcpConnection.getSocket();
+        while(true) {
+            if (socket != null) {
+                try {
+                    long startTime = System.nanoTime();
+                    InputStream in = socket.getInputStream();
+                    Integer id = new Integer(-1);
+                    int n = 0;
+                    if (in instanceof ChannelInputStream) {
+                        n = ((ChannelInputStream) in).readMittcpu(id);
+                    } else {
+                        n = in.read();
+                    }
+                    if (n == -16) {
+                        System.out.println("  rejection msgid: " + id.toString() + "  endpoint: " 
+                                    + outboundTcpConnection.getSocket().getInetAddress().getHostAddress());
+                        long endTime = System.nanoTime();
+                        long latency = endTime - startTime;
+                        double latencyDouble = ((double) latency) / 1000000;
+                    
+                    
+//                  System.out.println("        @meng: RecvRunnable have waited for " + Double.toString(latencyDouble) + "ms");
+                    
+                        CallbackInfo callbackInfo = MessagingService.instance().removeRegisteredCallback(id.intValue());
+                        if (callbackInfo == null) {
+                            System.out.println("    @meng: callback not found for msgid " + Integer.toString(id));
+                            continue;
+                        }
+//                    
+                        IAsyncCallback cb = callbackInfo.callback;
+                        if (cb instanceof ReadCallback) {
+                            System.out.println("    @meng: " + System.currentTimeMillis() + " - " 
+                                + Long.toString(((ReadCallback) cb).getExecutor().getCommandCounter()) 
+                                + " - Request is Mittcpu Reject from " + socket.getRemoteSocketAddress().toString()
+                                + " after " + Double.toString(latencyDouble) + "ms");
+                            ((ReadCallback) cb).onMittcpuRejection();
+                        }
+                    }
+                } catch (Exception e) {
+                    if (outboundTcpConnection.getSocket().isClosed()) {
+                        System.out.println("    @meng: RecvTcpLoop: socket is closed.");
+                    }
+                    else {
+                        System.out.println("   @meng: error in RecvTcpLoop:");
+                        e.printStackTrace();
+                    }
+                }
+            
+            }
+        }
+        
+    }
+    
+    
+}
+
+
diff --git a/src/java/org/apache/cassandra/service/AbstractReadExecutor.java b/src/java/org/apache/cassandra/service/AbstractReadExecutor.java
index 572ae6e20d..26a7d7a6f1 100644
--- a/src/java/org/apache/cassandra/service/AbstractReadExecutor.java
+++ b/src/java/org/apache/cassandra/service/AbstractReadExecutor.java
@@ -41,6 +41,7 @@ import org.apache.cassandra.exceptions.UnavailableException;
 import org.apache.cassandra.metrics.ReadRepairMetrics;
 import org.apache.cassandra.net.MessageOut;
 import org.apache.cassandra.net.MessagingService;
+import org.apache.cassandra.net.RecvRunnable;
 import org.apache.cassandra.schema.SpeculativeRetryParam;
 import org.apache.cassandra.service.StorageProxy.LocalReadRunnable;
 import org.apache.cassandra.tracing.TraceState;
@@ -62,12 +63,22 @@ public abstract class AbstractReadExecutor
     protected final List<InetAddress> targetReplicas;
     protected final ReadCallback handler;
     protected final TraceState traceState;
+    long commandCounter = 0;
+    
+    public void setCommandCounter(long cc) {
+        this.commandCounter = cc;
+    }
+    
+    public long getCommandCounter() {
+        return this.commandCounter;
+    }
 
     AbstractReadExecutor(Keyspace keyspace, ReadCommand command, ConsistencyLevel consistencyLevel, List<InetAddress> targetReplicas, long queryStartNanoTime)
     {
         this.command = command;
         this.targetReplicas = targetReplicas;
         this.handler = new ReadCallback(new DigestResolver(keyspace, command, consistencyLevel, targetReplicas.size()), consistencyLevel, command, targetReplicas, queryStartNanoTime);
+        this.handler.setExecutor(this);
         this.traceState = Tracing.instance.get();
 
         // Set the digest version (if we request some digests). This is the smallest version amongst all our target replicas since new nodes
@@ -82,16 +93,20 @@ public abstract class AbstractReadExecutor
 
     protected void makeDataRequests(Iterable<InetAddress> endpoints)
     {
-        makeRequests(command, endpoints);
-
+        makeRequests(command, endpoints, 0);
+    }
+    
+    protected void makeDataRequestsMittcpu(Iterable<InetAddress> endpoints)
+    {
+        makeRequests(command, endpoints, 1);
     }
 
     protected void makeDigestRequests(Iterable<InetAddress> endpoints)
     {
-        makeRequests(command.copyAsDigestQuery(), endpoints);
+        makeRequests(command.copyAsDigestQuery(), endpoints, 0);
     }
 
-    private void makeRequests(ReadCommand readCommand, Iterable<InetAddress> endpoints)
+    private void makeRequests(ReadCommand readCommand, Iterable<InetAddress> endpoints, int deadline)
     {
         boolean hasLocalEndpoint = false;
 
@@ -107,7 +122,15 @@ public abstract class AbstractReadExecutor
                 traceState.trace("reading {} from {}", readCommand.isDigestQuery() ? "digest" : "data", endpoint);
             logger.trace("reading {} from {}", readCommand.isDigestQuery() ? "digest" : "data", endpoint);
             MessageOut<ReadCommand> message = readCommand.createMessage(MessagingService.instance().getVersion(endpoint));
-            MessagingService.instance().sendRRWithFailure(message, endpoint, handler);
+            
+            message.setDeadline(deadline);
+            if (deadline > 0) {
+                System.out.println("    @meng: " + System.currentTimeMillis() + " - " + Long.toString(this.commandCounter)
+                        + " Sending MittCPU request to " + endpoint.getHostAddress());
+                MessagingService.instance().sendRRWithFailureMittcpu(message, endpoint, handler);
+            } else {
+                MessagingService.instance().sendRRWithFailure(message, endpoint, handler);
+            }
         }
 
         // We delay the local (potentially blocking) read till the end to avoid stalling remote requests.
@@ -152,12 +175,16 @@ public abstract class AbstractReadExecutor
     {
         Keyspace keyspace = Keyspace.open(command.metadata().ksName);
         List<InetAddress> allReplicas = StorageProxy.getLiveSortedEndpoints(keyspace, command.partitionKey());
+        
+        
         // 11980: Excluding EACH_QUORUM reads from potential RR, so that we do not miscount DC responses
         ReadRepairDecision repairDecision = consistencyLevel == ConsistencyLevel.EACH_QUORUM
                                             ? ReadRepairDecision.NONE
                                             : command.metadata().newReadRepairDecision();
+        
         List<InetAddress> targetReplicas = consistencyLevel.filterForQuery(keyspace, allReplicas, repairDecision);
-
+        
+        
         // Throw UAE early if we don't have enough replicas.
         consistencyLevel.assureSufficientLiveNodes(keyspace, targetReplicas);
 
@@ -174,9 +201,28 @@ public abstract class AbstractReadExecutor
         // 11980: Disable speculative retry if using EACH_QUORUM in order to prevent miscounting DC responses
         if (retry.equals(SpeculativeRetryParam.NONE)
             || consistencyLevel == ConsistencyLevel.EACH_QUORUM
-            || consistencyLevel.blockFor(keyspace) == allReplicas.size())
-            return new NeverSpeculatingReadExecutor(keyspace, command, consistencyLevel, targetReplicas, queryStartNanoTime);
+            || consistencyLevel.blockFor(keyspace) == allReplicas.size()) {
+            if (targetReplicas.size() == allReplicas.size()) {
+                return new NeverSpeculatingReadExecutor(keyspace, command, consistencyLevel, targetReplicas, queryStartNanoTime);
+            }
+            InetAddress extraReplica = allReplicas.get(targetReplicas.size());
+            if (repairDecision == ReadRepairDecision.DC_LOCAL && targetReplicas.contains(extraReplica))
+            {
+                for (InetAddress address : allReplicas)
+                {
+                    if (!targetReplicas.contains(address))
+                    {
+                        extraReplica = address;
+                        break;
+                    }
+                }
+            }
+            targetReplicas.add(extraReplica);
+            return new MittcpuReadExecutor(keyspace, command, consistencyLevel, targetReplicas, queryStartNanoTime);
 
+        }
+            
+            
         if (targetReplicas.size() == allReplicas.size())
         {
             // CL.ALL, RRD.GLOBAL or RRD.DC_LOCAL and a single-DC.
@@ -233,6 +279,39 @@ public abstract class AbstractReadExecutor
         }
     }
 
+    
+    public static class MittcpuReadExecutor extends AbstractReadExecutor
+    {
+        public MittcpuReadExecutor(Keyspace keyspace, ReadCommand command, ConsistencyLevel consistencyLevel, List<InetAddress> targetReplicas, long queryStartNanoTime)
+        {
+            super(keyspace, command, consistencyLevel, targetReplicas, queryStartNanoTime);
+        }
+
+        public void executeAsync()
+        {
+            makeDataRequestsMittcpu(targetReplicas.subList(0, 1));
+
+            if (targetReplicas.size() > 1) {
+                List<InetAddress> initialReplicas = targetReplicas.subList(0, targetReplicas.size() - 1);
+                if (initialReplicas.size() > 1)
+                    makeDigestRequests(initialReplicas.subList(1, targetReplicas.size()));
+            }
+        }
+
+        public void maybeTryAdditionalReplicas()
+        {
+            // no-op
+        }
+
+        public Collection<InetAddress> getContactedReplicas()
+        {
+            return targetReplicas.subList(0, targetReplicas.size() - 1);
+        }
+    }
+    
+    
+    
+    
     private static class SpeculatingReadExecutor extends AbstractReadExecutor
     {
         private final ColumnFamilyStore cfs;
diff --git a/src/java/org/apache/cassandra/service/ReadCallback.java b/src/java/org/apache/cassandra/service/ReadCallback.java
index 3ef2faca28..1c4514693d 100644
--- a/src/java/org/apache/cassandra/service/ReadCallback.java
+++ b/src/java/org/apache/cassandra/service/ReadCallback.java
@@ -69,6 +69,21 @@ public class ReadCallback implements IAsyncCallbackWithFailure<ReadResponse>
     private final Map<InetAddress, RequestFailureReason> failureReasonByEndpoint;
 
     private final Keyspace keyspace; // TODO push this into ConsistencyLevel?
+    
+    
+    private AbstractReadExecutor executor;
+    
+    public void setExecutor(AbstractReadExecutor executor)
+    {
+        this.executor = executor;
+    }
+    
+    public AbstractReadExecutor getExecutor()
+    {
+        return this.executor;
+    }
+    
+    
 
     /**
      * Constructor when response count has to be calculated and blocked for.
@@ -155,6 +170,10 @@ public class ReadCallback implements IAsyncCallbackWithFailure<ReadResponse>
 
     public void response(MessageIn<ReadResponse> message)
     {
+        System.out.println("    @meng: Received response from " + message.from.getHostAddress());
+        long latency = System.nanoTime() - queryStartNanoTime;
+        double latencyDouble = ((double) latency) / 1000000;
+        System.out.println("        @meng: receive response have waited for " + Double.toString(latencyDouble) + "ms");
         resolver.preprocess(message);
         int n = waitingFor(message.from)
               ? recievedUpdater.incrementAndGet(this)
@@ -172,7 +191,7 @@ public class ReadCallback implements IAsyncCallbackWithFailure<ReadResponse>
                 StageManager.getStage(Stage.READ_REPAIR).execute(new AsyncRepairRunner(traceState, queryStartNanoTime));
             }
         }
-    }
+    } 
 
     /**
      * @return true if the message counts towards the blockfor threshold
@@ -267,4 +286,15 @@ public class ReadCallback implements IAsyncCallbackWithFailure<ReadResponse>
         if (blockfor + n > endpoints.size())
             condition.signalAll();
     }
+    
+    public void onMittcpuRejection() {
+        ReadCommand retryCommand = executor.command;
+        InetAddress extraReplica = executor.targetReplicas.get(executor.targetReplicas.size() - 1);
+        int version = MessagingService.instance().getVersion(extraReplica);
+        System.out.println("    @meng: sending Failover message to " + extraReplica.getHostAddress());
+        MessagingService.instance().sendRRWithFailure(retryCommand.createMessage(version), extraReplica, this);
+        long latency = System.nanoTime() - queryStartNanoTime;
+        double latencyDouble = ((double) latency) / 1000000;
+        System.out.println("        @meng: send failover have waited for " + Double.toString(latencyDouble) + "ms");
+    }
 }
diff --git a/src/java/org/apache/cassandra/service/StorageProxy.java b/src/java/org/apache/cassandra/service/StorageProxy.java
index 15fe938f77..8057893839 100644
--- a/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -76,6 +76,8 @@ public class StorageProxy implements StorageProxyMBean
 {
     public static final String MBEAN_NAME = "org.apache.cassandra.db:type=StorageProxy";
     private static final Logger logger = LoggerFactory.getLogger(StorageProxy.class);
+    
+    public static long commandCounter = 0;
 
     public static final String UNREACHABLE = "UNREACHABLE";
 
@@ -1722,7 +1724,11 @@ public class StorageProxy implements StorageProxyMBean
     throws UnavailableException, ReadFailureException, ReadTimeoutException
     {
         int cmdCount = commands.size();
-
+        
+        System.out.println("    @meng: " + Long.toString(System.currentTimeMillis()) + " - " + Long.toString(commandCounter) 
+                + " - fetching rows....");
+        long startTime = System.nanoTime();
+                        
         SinglePartitionReadLifecycle[] reads = new SinglePartitionReadLifecycle[cmdCount];
         for (int i = 0; i < cmdCount; i++)
             reads[i] = new SinglePartitionReadLifecycle(commands.get(i), consistencyLevel, queryStartNanoTime);
@@ -1746,6 +1752,12 @@ public class StorageProxy implements StorageProxyMBean
             assert reads[i].isDone();
             results.add(reads[i].getResult());
         }
+        
+        long endTime = System.nanoTime();
+        long latency = endTime - startTime;
+        double latencyDouble = ((double) latency) / 1000000;
+        
+//        System.out.println("        @meng: have waited for " + Double.toString(latencyDouble) + "ms");
 
         return PartitionIterators.concat(results);
     }
@@ -1764,6 +1776,8 @@ public class StorageProxy implements StorageProxyMBean
         {
             this.command = command;
             this.executor = AbstractReadExecutor.getReadExecutor(command, consistency, queryStartNanoTime);
+            this.executor.setCommandCounter(commandCounter);
+            commandCounter += 1;
             this.consistency = consistency;
             this.queryStartNanoTime = queryStartNanoTime;
         }
